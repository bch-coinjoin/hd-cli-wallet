/*
  This library retrieves data from the blockchain and updates the wallet
  data to reflect its current state, based on the results of the data coming
  back from the blockchain.
*/

// External npm libraries
const BchConsumer = require('bch-consumer')

// Local libraries
const AppUtils = require('../util')

class UpdateBalanceLib {
  constructor (localConfig = {}) {
    // Default REST API server
    let restURL = 'https://free-bch.fullstack.cash'
    // Allow the user to overwrite the server.
    if (localConfig.restURL) restURL = localConfig.restURL
    console.log('restURL: ', restURL)

    // Encapsulate dependencies
    this.appUtils = new AppUtils()
    this.bchConsumer = new BchConsumer({ restURL })
  }

  // This is a top-level function that orchestrates the other subfunctions, in
  // order to take a wallet object with a mnemonic and update it with UTXO and
  // balance data from the blockchain.
  async updateWallet (walletInfo) {
    try {
      // Query data on each address that has been generated by the wallet.
      const rawAddressData = await this.getAllAddressData({ walletInfo })
      // console.log(`rawAddressData: ${JSON.stringify(rawAddressData, null, 2)}`)

      // Update hasBalance array with non-zero balances.
      const hasBalance = this.generateHasBalance(rawAddressData)
      walletInfo.hasBalance = hasBalance
      // console.log(`hasBalance: ${JSON.stringify(hasBalance, null, 2)}`)

      // Update the bchUtxos array with addresses that have BCH UTXOs.
      const bchUtxos = this.generateBchUtxos(rawAddressData)
      walletInfo.bchUtxos = bchUtxos
      console.log('bchUtxos: ', JSON.stringify(bchUtxos, null, 2))

      // TODO: Add a functoin here similar to generateBchUtxos, but instead
      // extracts the Type1 SLP token UTXOs.

      // console.log('walletInfo: ', walletInfo)

      // TODO: Update the nextAddress property based on the biggest address
      // that had a balance (or preferably a TX history)

      // Sum all the balances in hasBalance to calculate total balance.
      const balanceTotalSat = this.sumBalances(hasBalance)
      walletInfo.balanceTotalSat = balanceTotalSat
      console.log('balanceTotalSat: ', balanceTotalSat)

      return walletInfo
    } catch (err) {
      console.error('Error in update-balance.js/updateWallet()')
      throw err
    }
  }

  // Retrieves details data (objects) on addresses in an HD wallet from REST server.
  // A max of 20 addresses can be retrieved at a time.
  // Addresses start at the index and the number of address data retrieved is
  // set by the limit (up to 20). Data is returned as an object with balance and
  // hydrated utxo data.
  async getAddressData (inObj = {}) {
    // This is a complex function. Here are the high-level outline of the workflow:
    // - Input validation
    // - Generate an array of 20 addresses from the HD wallet.
    // - Get the balances for each address
    // - Get the UTXOs for each address
    // - Return an object with balances and UTXO information for each address.

    try {
      // Input validation
      const { walletInfo, index, limit } = inObj

      if (isNaN(index)) throw new Error('index must be supplied as a number.')

      if (!limit || isNaN(limit)) {
        throw new Error('limit must be supplied as a non-zero number.')
      }

      if (limit > 20) throw new Error('limit must be 20 or less.')

      console.log(
        `Getting address data from index ${index} to index ${index + limit - 1}`
      )

      // Get the list of addresses.
      const { bulkAddresses, bulkAddressesWithIndex } = await this.appUtils.generateAddresses(
        walletInfo,
        index,
        limit
      )
      // console.log('bulkAddressesWithIndex: ', bulkAddressesWithIndex)
      // console.log('bulkAddresses: ', bulkAddresses)

      // get BCH balance and details for each address.
      const balancesAry = await this.bchConsumer.bch.getBalance(bulkAddresses)
      // console.log(`balancesAry 1: ${JSON.stringify(balancesAry, null, 2)}`)

      // Add the HD Index to each balance.
      for (let i = 0; i < balancesAry.balances.length; i++) {
        const thisAddr = balancesAry.balances[i]

        // Find the entry in the bulkAddressesWithIndex entry that matches
        // the address for this balance.
        const thisIndex = bulkAddressesWithIndex.find(x => x.addr === thisAddr.address)
        // console.log('thisIndex: ', thisIndex)

        // Add the HD index for this address to the object.
        thisAddr.hdIndex = thisIndex.hdIndex

        // Add the total to the object
        thisAddr.balance.total = thisAddr.balance.confirmed + thisAddr.balance.unconfirmed
      }
      // console.log(`balancesAry 2: ${JSON.stringify(balancesAry, null, 2)}`)

      // Get UTXO data.
      const utxos = await this.bchConsumer.bch.getUtxos(bulkAddresses)
      // console.log(`utxos 1: ${JSON.stringify(utxos, null, 2)}`)

      // Add the HD index to each entry of UTXOs
      for (let i = 0; i < utxos.data.length; i++) {
        const thisAddr = utxos.data[i]

        // Find the entry in the bulkAddressesWithIndex entry that matches
        // the address for these UTXOs.
        const thisIndex = bulkAddressesWithIndex.find(x => x.addr === thisAddr.address)

        // Add the HD index for this address to the object.
        thisAddr.hdIndex = thisIndex.hdIndex
      }
      // console.log(`utxos 2: ${JSON.stringify(utxos, null, 2)}`)

      const outObj = {
        addresses: bulkAddresses,
        balances: balancesAry.balances,
        utxos: utxos.data
      }

      return outObj
    } catch (err) {
      // console.log('Error: ', err)
      console.log('Error in update-balance.js/getAddressData(): ', err.message)
      throw err
    }
  }

  // Retrieves data for the last 100 addresses in the wallet (default behavior).
  // This function can also be used to scan every address generated by the wallet,
  // if it is larger than 100 addresses.
  async getAllAddressData (inObj = {}) {
    try {
      const { walletInfo, scanEntireWallet } = inObj

      // Calculate how many addresses will be scanned.
      const stopIndex = walletInfo.nextAddress
      let startIndex = 0
      if (stopIndex > 100) startIndex = stopIndex - 100
      if (scanEntireWallet) startIndex = 0

      const outObj = {
        addresses: [],
        balances: [],
        utxos: []
      }

      // Loop through the HD indexes in increments of 20.
      for (let i = startIndex; i < stopIndex; i += 20) {
        const index = i
        const limit = 20

        const setOf20 = await this.getAddressData({ walletInfo, index, limit })
        // console.log('setOf20: ', setOf20)

        // Concat the new data
        outObj.addresses = outObj.addresses.concat(setOf20.addresses)
        outObj.balances = outObj.balances.concat(setOf20.balances)
        outObj.utxos = outObj.utxos.concat(setOf20.utxos)
      }

      return outObj
    } catch (err) {
      console.error('Error in update-balance.js/getAllAddressData(): ', err.message)
      throw err
    }
  }

  // This function expects the output of getAllAddressData() as its input.
  //
  // The purpose of this function is to reduce lots of empty address data to
  // just the addresses with balances.
  //
  // It loops through that raw data and returns an array of objects. Each object
  // contains the address and balance for that address. Addresses without
  // balances are ignored.
  generateHasBalance (inObj = {}) {
    try {
      // const { addresses, balances, utxos } = inObj
      const { balances } = inObj
      // console.log('generateHasBalance() balances: ', JSON.stringify(balances, null, 2))

      const outAry = []

      for (let i = 0; i < balances.length; i++) {
        const thisBalance = balances[i]

        if (thisBalance.balance.total > 0) {
          const tempObj = {
            balanceSat: thisBalance.balance.total,
            address: thisBalance.address,
            hdIndex: thisBalance.hdIndex
          }

          outAry.push(tempObj)
        }
      }

      return outAry
    } catch (err) {
      console.error('Error in update-balance.js/generateHasBalance(): ', err.message)
      throw err
    }
  }

  // This function expects the output of generateHasBalance() as its input.
  // It loops through all the addresses with a balance and sums the balances,
  // to achieve a total amount of BCH held by the HD wallet.
  // The value returned is in satoshis (not BCH)
  sumBalances (hasBalanceAry = []) {
    // console.log('sumBalances() hasBalanceAry: ', hasBalanceAry)

    let total = 0

    for (let i = 0; i < hasBalanceAry.length; i++) {
      total += hasBalanceAry[i].balanceSat
    }

    return total
  }

  // This function is similar to generateHasBalance(). It loops through the
  // UTXO array as input, and as output, gives an array of objects. Each object
  // is an address that contains BCH UTXOs.
  generateBchUtxos (inObj = {}) {
    try {
      // const { addresses, balances, utxos } = inObj
      const { utxos } = inObj
      // console.log('generateBchUtxos() utxos: ', JSON.stringify(utxos, null, 2))

      const outAry = []

      for (let i = 0; i < utxos.length; i++) {
        const thisAddr = utxos[i]

        if (thisAddr.utxos.bchUtxos.length > 0) {
          const tempObj = {
            bchUtxos: thisAddr.utxos.bchUtxos,
            address: thisAddr.address,
            hdIndex: thisAddr.hdIndex
          }

          outAry.push(tempObj)
        }
      }

      return outAry
    } catch (err) {
      console.error('Error in update-balance.js/generateHasBalance(): ', err.message)
      throw err
    }
  }
}

module.exports = UpdateBalanceLib
